# üë©üèª‚Äçüíª Ikhlas Nassif

**`Desenvolvedor Back-end`**

Me chamo Ikhlas Santos Nassif, tenho 19 anos e sou natural da Bahia. Conclu√≠ o ensino m√©dio no col√©gio Nobre, tenho tamb√©m curso de ingl√™s pelo CCAA. Atualmente, estou cursando Engenharia de Computa√ß√£o na UEFS. Sou proativo, dedicado, respons√°vel e aut√¥nomo, conhe√ßa um pouco mais de mim pelo meu [Linkedin](https://www.linkedin.com/in/ikhlasnassif/).

<p align="left">
    <a href="https://github.com/isnassif?tab=repositories&sort=stargazers">
        <img 
            alt="Total de estrelas" 
            title="Total de estrelas GitHub" 
            src="https://custom-icon-badges.demolab.com/github/stars/isnassif?color=55960c&style=for-the-badge&labelColor=488207&logo=star&label=estrelas"
        />
    </a>
    <a href="https://github.com/isnassif?tab=followers">
        <img 
            alt="Seguidores" 
            title="Me siga no GitHub" 
            src="https://custom-icon-badges.demolab.com/github/followers/isnassif?color=236ad3&labelColor=1155ba&style=for-the-badge&logo=github&label=Seguidores&logoColor=white"
        />
    </a>
</p>

<h2 id="control">Unidade de Controle</h2>
<p>
A Unidade de Controle, √© implementada no m√≥dulo control_unity e funciona como o elemento principal do projeto, ela √© respons√°vel por coordenar todo o fluxo do sistema, come√ßando pela instancia√ß√£o de todos os componentes principais, como as mem√≥rias ROM e RAM e a ALU, coordena√ß√£o e gera√ß√£o do clock utilizado, sincronismo das chaves utilizadas, ativa√ß√£o dos algoritmos de redimensionamento e escrita ordenada no Framebuffer, com um resultado final exibido pelo driver VGA, a seguir, ser√° explicado de forma detalhada e minunciosa o funcionamento de cada um dos componentes do m√≥dulo.
</p>

<h3>Fun√ß√µes Principais</h3>
<ul>
  <li><strong>Gera√ß√£o e Distribui√ß√£o de Clocks:</strong>  
      Atrav√©s da ferramente "IP catalog", dispon√≠vel na IDE Quartus (utiliada para o desenvolvimento do projeto), foi criado um PLL para fornecer um clock est√°vel aos blocos de mem√≥ria, o que fornece uma valor preciso para os m√≥dulos principais.</li>
  <li><strong>Sincroniza√ß√£o de Entradas:</strong>  
      As chaves sw s√£o sincronizadas em registradores para evitar metastabilidade. Esses sinais determinam o modo de opera√ß√£o (replica√ß√£o, decima√ß√£o, zoom por vizinho mais pr√≥ximo ou c√≥pia direta).</li>
  <li><strong>Centraliza√ß√£o e Endere√ßamento:</strong>  
      Calcula dinamicamente x_offset e y_offset, sinais do vga_driver, para centralizar a imagem na tela de 640√ó480, utilizada para desenvolvimento do projeto, esses sinais, geram o endere√ßo do Framebuffer para cada pixel v√°lido.</li>
  <li><strong>Controle da FSM:</strong>  
      A FSM do m√≥dulo de controle coordena a leitura de pixels da ROM, aciona o m√≥dulo de algoritmo selecionado e controla os sinais de escrita na RAM, permitindo com que o projeto funcione da melhor forma.</li>
</ul>

<h3>Fluxo Operacional</h3>
<p>
    Nessa se√ß√£o, falaremos sobre toda a parte operacional do funcionamento da Unidade de Controle, que segue uma sequ√™ncia bem definida de etapas. Inicialmente, assim que o sinal vga_reset √© acionado, o sistema entra no estado de RESET. Nesse momento, s√£o realizados os ajustes iniciais, incluindo a configura√ß√£o dos fatores de escala de acordo com a op√ß√£o escolhida pelo usu√°rio por meio das chaves de entrada. Com a configura√ß√£o conclu√≠da, o sistema passa para a fase de leitura sequencial da ROM. Aqui, o endere√ßo rom_addr √© continuamente incrementado, percorrendo toda a imagem original armazenada, que possui resolu√ß√£o de 160√ó120 pixels. Cada pixel lido √© ent√£o encaminhado para o m√≥dulo de algoritmo respons√°vel pelo redimensionamento.
</p>

<p>
    A etapa de redimensionamento √© basicamente √© o processamento do pixel pelo algoritmo selecionado, vale ressaltar que a escolha do modo de opera√ß√£o depende do c√≥digo de controle gerado a partir das chaves. Assim, o pixel pode ser replicado, reduzido, interpolado ou simplesmente copiado de forma direta - Por exemplo, no modo de replica√ß√£o √ó2, cada pixel proveniente da ROM √© expandido em quatro pixels consecutivos que ser√£o gravados no framebuffer- Ap√≥s o processamento, leitura e aplica√ß√£o dos algoritmos, ocorre a escrita na RAM dual-port, que funciona como framebuffer. A posi√ß√£o de mem√≥ria correta √© calculada a partir do registrador de endere√ßo addr_reg, levando em conta tanto a amplia√ß√£o ou redu√ß√£o da imagem quanto os deslocamentos necess√°rios para centraliza√ß√£o. O sinal de controle ram_wren garante que a escrita ocorra apenas em ciclos v√°lidos, evitando sobreposi√ß√£o ou perda de dados.
</p>

<p>
    A unidade de controle tamb√©m controla o m√≥dulo vga_drive, que ser√° explicado posteriormente. Esse fluxo coordenado garante que cada etapa ‚Äî desde a leitura da ROM at√© a exibi√ß√£o final pelo VGA ‚Äî seja sincronizada e controlada pela Unidade de Controle, assegurando o funcionamento est√°vel do sistema.
</p>

<h3>Integra√ß√£o com os Demais Blocos</h3>
<p>
A Unidade de Controle conecta e organiza todos os m√≥dulos do sistema:
</p>
<ul>
  <li><strong>ROM:</strong> fornece pixels originais.</li>
  <li><strong>M√≥dulos de Algoritmo:</strong> recebem dados e aplicam o redimensionamento.</li>
  <li><strong>RAM (Framebuffer):</strong> armazena a imagem processada e serve de interface com o VGA.</li>
  <li><strong>Driver VGA:</strong> exibe a imagem final centralizada na tela.</li>
</ul>

<h3>Exemplo de Opera√ß√£o</h3>
<p>
Suponha que o usu√°rio selecione <code>sw = 4'b0000</code> (replica√ß√£o √ó2).  
Nesse caso:
</p>
<ul>
  <li>A Unidade de Controle configura <code>IMG_W_AMP = 320</code> e <code>IMG_H_AMP = 240</code>.</li>
  <li>Os offsets s√£o <code>x_offset = 160</code>, <code>y_offset = 120</code>, garantindo centraliza√ß√£o.</li>
  <li>Cada pixel da ROM √© replicado em 4 posi√ß√µes consecutivas na RAM.</li>
  <li>O VGA exibe uma imagem de 320√ó240 pixels centralizada em 640√ó480.</li>
</ul>

<h3>Pontos de Aten√ß√£o</h3>
<ul>
  <li>O reset <code>vga_reset</code> √© ativo em n√≠vel baixo: a documenta√ß√£o deve enfatizar esse detalhe para evitar erros.</li>
  <li>Existe travessia de dom√≠nios de clock (<code>clk_vga</code> √ó <code>outclk_0</code>), devendo-se confirmar que a RAM e a ROM suportam opera√ß√£o dual-clock.</li>
  <li>√â importante debouncing das chaves (<code>sw</code>) para garantir estabilidade nas trocas de modo em tempo de execu√ß√£o.</li>
</ul>

